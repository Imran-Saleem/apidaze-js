import Call from './Call.js';
import Logger from './Logger.js';

var __VERSION__ = "dev-" + process.env.__VERSION__ // webpack defineplugin variable

var STATUS_INIT =                 1;
var STATUS_WSOPENED =             2;
var STATUS_RECVD_PONG =           4;
var STATUS_NOTREADY =             8;
var LOG_PREFIX = 'APIdaze-' + __VERSION__ + ' | CLIENT |';
var LOGGER = new Logger(false, LOG_PREFIX);

var CLIENT = function(configuration){
  let { apiKey, wsurl, onReady, onDisconnected, onError, status = STATUS_INIT, debug } = configuration;

  // User defined handlers
  this._onDisconnected = onDisconnected || function(){ LOGGER.log("Disconnected") };
  this._onReady = onReady || function(){ LOGGER.log("Ready") };
  this._onError = function(message){
    typeof onError === "function" ? onError(message) : LOGGER.log("Error : " + message);
    throw {ok: false, message: message}
  };

  if (debug) {
    this.debug = true;
    LOGGER._debug = true;
  } else {
    this.debug = false;
  }

  if (!apiKey){
    this._onError("Please provide apiKey")
  }

  if (!"WebSocket" in window) {
    this._onError("WebSocket not supported")
  }

  if (!/wss:\/\//.test(wsurl)) {
    this._onError("Wrong WebSocket URL, must start with wss://")
  }

  this._callArray = [];
  this._apiKey = apiKey;
  this._status = status;

  this._websocket = new WebSocket(wsurl);
  this._websocket.onopen = handleWebSocketOpen.bind(this);
  this._websocket.onerror = handleWebSocketError.bind(this);
  this._websocket.onmessage = handleWebSocketMessage.bind(this);
  this._websocket.onclose = handleWebSocketClose.bind(this);
}

CLIENT.prototype.type = function() {
  return this._type;
}

CLIENT.prototype.version = __VERSION__

CLIENT.prototype.sendMessage = function(json){
  LOGGER.log("handleWebSocketMessage | C->S : " + json);
  this._websocket.send(json);
}

CLIENT.prototype.call = function(params, listeners){
  try {
    var callObj = new Call(this, params, listeners);
    this._callArray.push(callObj);
    return callObj;
  } catch(error){
    this._onError(error);
  }
}

/**
* Log connection event and update status
*/
const handleWebSocketOpen = function(){
  LOGGER.log("handleWebSocketOpen | WebSocket opened");
  this._status *= STATUS_WSOPENED;

  var request = {};
  request.wsp_version = "1";
  request.method = "ping";
  request.params = {};
  this.sendMessage(JSON.stringify(request));
}

/**
* Call CLIENT.onError() and throw error
*/
const handleWebSocketError = function(){
  LOGGER.log("handleWebSocketError | Error ");
  this._onError("WebSocket error");
}

/**
* Handle messages from mod_verto
*/
const handleWebSocketMessage = function(event){
  LOGGER.log("handleWebSocketMessage | S->C : " + event.data);
  let json = JSON.parse(event.data);

  // Handle response to our initial 'subscribe_message' request
  if (/^subscribe_message/.test(json.id)){
    let callID = json.id.split('|')[1];
    handleSubscribeFromVerto.call(this, json, callID);
    return;
  }

  // Handle response to our initial 'conference blabla list' request
  if (/^conference_list_command/.test(json.id)){
    let callID = json.id.split('|')[1];
    handleConferenceListResponse.call(this, json, callID);
    return;
  }

  if (json.result) {
    // Process reponse after request from gateway
    if (json.result.message) {
      let callID = null; // generated by APIdaze
      let sessid = null; // gotten back from FreeSWITCH
      let index = -1;
      switch (json.result.message) {
        case "pong":
        this._status *= STATUS_RECVD_PONG;
        this._onReady();
        return;

        case "CALL CREATED":
        LOGGER.log("Got CALL CREATED event");
        callID = json.result.callID;
        sessid = json.result.sessid;
        index = this._callArray.findIndex(function(callObj){
          return callObj.callID === callID;
        });
        if (index < 0){
          LOGGER.log("Cannot find call with callID " + callID);
        } else {
          LOGGER.log("Call created with callID " + callID + " and sessid " + sessid);
          this._callArray[index].sessid = sessid;
        }
        return;

        case "CALL ENDED":
        LOGGER.log("Got CALL ENDED event");
        callID = json.result.callID;
        index = this._callArray.findIndex(function(callObj){
          return callObj.callID === callID;
        });
        if (index < 0){
          LOGGER.log("Cannot find call with callID " + callID)
        } else {
          LOGGER.log("Call ended with callID " + callID);
        }
        this._callArray[index]._onHangup();
        this._callArray[index] = null;
        this._callArray.splice(index, 1);
        return;

        default:
        break;
      }
    }

    if (json.result.action) {
      switch(json.result.action){
        case "sendDTMF":
        LOGGER.log("DTMF sent");
        return;
        default:
        return;
      }
    }
  }

  if (json.method === "event"){
    handleVertoEvent.call(this, json);
    return;
  }

  let callID = json.params.callID;
  let index = this._callArray.findIndex(function(callObj){
    return callObj.callID === callID;
  });

  if (index < 0){
    LOGGER.log("Cannot find call with callID " + callID)
  }

  /**
  * FreeSWITCH can send us its SDP from various actions :
  * media (early media)
  * answer
  * ringing (if using <ringtone/> or <ringback/> from the API)
  *
  * We need to check whenever we get an SDP from FreeSWITCH and
  * call setRemoteDescription right way
  */
  switch(json.method){
    case "media":
    // In this case, we consider the call is ringing
    LOGGER.log("Found call index : " + index);
    if (json.params.sdp){
      this._callArray[index].setRemoteDescription(json.params.sdp);
    }
    this._callArray[index]._onRinging();

    break;
    case "answer":
    LOGGER.log("Found call index : " + index);
    if (json.params.sdp){
      this._callArray[index].setRemoteDescription(json.params.sdp);
    }
    this._callArray[index]._onAnswer();

    break;
    case "hangup":
    LOGGER.log("Hangup call with callID " + this._callArray[index].callID);
    this._callArray[index]._onHangup();
    this._callArray[index] = null;
    this._callArray.splice(index, 1);

    break;
    case "ringing":
    LOGGER.log("Ringing on call with callID " + this._callArray[index].callID);
    // FS may send SDP along with ringing event
    if (json.params.sdp){
      this._callArray[index].setRemoteDescription(json.params.sdp);
    }
    this._callArray[index]._onRinging();

    break;
    default:
    LOGGER.log("No action for this message");
  }
}

/**
* Handle events from mod_verto here
*
* The main purpose is to handle conference events, but one may expect to
* get other events here.
*/
const handleVertoEvent = function(event){
  var params = event.params;
  LOGGER.log("Received event of type " + params.eventType);
  LOGGER.log("Event channel UUID : " + params.eventChannelUUID);
  var index = this._callArray.findIndex(function(callObj){
    return callObj.callID === params.eventChannelUUID;
  });

  if (index >= 0){
    // This is an event generated by one of our sessions (not a conference)
    LOGGER.log("Need to handle simple event");
    if (params.pvtData.action === "conference-liveArray-join"){
      /**
      * We receive this message the first time we join the conference.
      * Two actions performed :
      * - Send a subscribe message to FreeSWITCH in order to get all the
      *   conference events from this conference
      * - Retrieve list of current participants in the room
      */
      let request = {};
      request.wsp_version = "1";
      request.method = "verto.subscribe";
      request.id = "subscribe_message|" + this._callArray[index].callID;
      request.params = {
        eventChannel: [
          event.params.pvtData.laChannel,
          event.params.pvtData.chatChannel,
          event.params.pvtData.infoChannel
        ],
        subParams: {}
      };
      this.sendMessage(JSON.stringify(request));

      request.wsp_version = "1";
      request.method = "jsapi";
      request.id = "conference_list_command|" + this._callArray[index].callID;;
      request.params = {
        command: "fsapi",
        data: {
          cmd: "conference",
          arg: event.params.pvtData.laName + " list"
        }
      };
      this.sendMessage(JSON.stringify(request));

      /**
      * Set parameters to our callObj
      * - callType to 'conference'
      * - conferenceMemberID identifies me in the conference
      */
      this._callArray[index].callType = "conference";
      this._callArray[index].conferenceMemberID = parseInt(event.params.pvtData.conferenceMemberID);
      this._callArray[index].conferenceName = event.params.pvtData.laName;
    }

    return;
  }

  /**
  * Now let's check if the event is coming from a conference room
  */
  if (/^conference-liveArray/.test(event.params.eventChannel)){
    /**
    * That's a conference room event (TALKING, etc.), find the right callObj
    * and call its handler
    */
    index = this._callArray.findIndex(function(callObj){
      return callObj.subscribedChannels.laChannel === params.eventChannel;
    });

    if (index < 0){
      this._onError("Failed to find call object that matches with conf event");
    }

    switch(events.params.data.action){
      case "modify":
      // Who is talking events are received here
      this._callArray[index]._onRoomTalking(event.params.data.data);
      break;
      case "add":
      // Some joined the conference
      this._callArray[index]._onRoomAdd(event.params.data.data);
      break;
      case "del":
      this._callArray[index]._onRoomDel(event.params.data.data);
      break;
    }
  }

}

/**
* Handle response from FreeSWITCH to our initial verto.subscribe request
*/
const handleSubscribeFromVerto = function(event, callID){
  var index = this._callArray.findIndex(function(callObj){
    return callObj.callID === callID;
  });

  if (index < 0){
    LOGGER.log("Cannot find a call object that matches with sessid " + event.sessid);
    throw {ok: false, message: "Failed to process reply to subscribe"}
  }

  /**
  * I hope FreeSWITCH dumps the channels in the same order :
  * - laChannel : LiveArray, all events from the conference
  * - chatChannel : chat messages
  * - infoChannel : info ?
  */
  this._callArray[index].subscribedChannels = {}
  this._callArray[index].subscribedChannels.laChannel = event.result.subscribedChannels[0];
  this._callArray[index].subscribedChannels.chatChannel = event.result.subscribedChannels[1];
  this._callArray[index].subscribedChannels.infoChannel = event.result.subscribedChannels[2];
  this._callArray[index].subscribedChannelsArray = event.result.subscribedChannels;
}

/**
* Handle response from FreeSWITCH to our 'conference_list_command'
*
* We just get the list of the participants in the conference room we're joining.
*/
const handleConferenceListResponse = function(event, callID){
  var index = this._callArray.findIndex(function(callObj){
    return callObj.callID === callID;
  });

  if (index < 0){
    LOGGER.log("Cannot find a call object that matches with sessid " + event.sessid);
    throw {ok: false, message: "Failed to process reply to conference_list_command"}
  }

  LOGGER.log("Got members " + JSON.stringify(event));
  var members = [];
  var lines = event.result.message.split('\n');
  for (var idx = 0; idx < lines.length - 1; idx++) {
    var elems = lines[idx].split(';');
    members.push({
      sessid: elems[2],
      nickname: elems[3],
      caller_id_number: elems[4],
      conferenceMemberID: elems[0],
      talking_flags: elems[5]
    });
  }

  this._callArray[index]._onRoomMembersInitialList(members);
}

/**
* Log connection event, update status, call CLIENT.onDisconnected()
*/
const handleWebSocketClose = function(err){
  LOGGER.log("handleWebSocketClose | WebSocket closed");
  this._status = STATUS_INIT;
  this._onDisconnected();
}

export default CLIENT
